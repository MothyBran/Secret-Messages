# swagger/openapi.yaml - OpenAPI 3.0 Specification
openapi: 3.0.3
info:
  title: Secret Messages API
  description: |
    Enterprise-grade encryption service with license key management and payment processing.
    
    ## Features
    - AES-256 hybrid encryption
    - License key authentication
    - Payment processing via Stripe
    - Session management
    - Activity logging
    
    ## Authentication
    Most endpoints require authentication via JWT tokens obtained through license key activation.
    
    ## Rate Limiting
    - General API: 100 requests per 15 minutes
    - Authentication: 5 requests per 15 minutes
    - Admin endpoints: 10 requests per 15 minutes
    
  version: 1.0.0
  contact:
    name: Secret Messages Support
    email: support@secretmessages.dev
    url: https://secretmessages.dev/support
  license:
    name: MIT License
    url: https://opensource.org/licenses/MIT
  termsOfService: https://secretmessages.dev/terms

servers:
  - url: https://api.secretmessages.dev/api
    description: Production server
  - url: https://staging-api.secretmessages.dev/api
    description: Staging server
  - url: http://localhost:3000/api
    description: Development server

security:
  - BearerAuth: []

paths:
  /health:
    get:
      summary: Health check endpoint
      description: Returns the health status of the API
      tags:
        - System
      security: []
      responses:
        '200':
          description: Service is healthy
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                    example: ok
                  timestamp:
                    type: string
                    format: date-time
                  version:
                    type: string
                    example: 1.0.0
                  uptime:
                    type: number
                    description: Uptime in seconds

  /auth/activate:
    post:
      summary: Activate license key
      description: |
        Activates a license key and returns an authentication token.
        The key will be bound to the device's IP address and can only be used once.
      tags:
        - Authentication
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - licenseKey
              properties:
                licenseKey:
                  type: string
                  pattern: '^[A-Z0-9]{5}-[A-Z0-9]{5}-[A-Z0-9]{5}$'
                  example: "SM001-ALPHA-BETA1"
                  description: License key in format XXXXX-XXXXX-XXXXX
      responses:
        '200':
          description: License key activated successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  message:
                    type: string
                    example: "License key activated successfully"
                  token:
                    type: string
                    description: JWT authentication token
                  keyId:
                    type: integer
                    description: Internal key ID
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          description: License key not found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '403':
          description: License key already bound to another device
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /auth/validate:
    post:
      summary: Validate session token
      description: Validates an existing authentication token
      tags:
        - Authentication
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - token
              properties:
                token:
                  type: string
                  description: JWT token to validate
      responses:
        '200':
          description: Token is valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  valid:
                    type: boolean
                    example: true
                  keyId:
                    type: integer
        '401':
          $ref: '#/components/responses/Unauthorized'

  /auth/logout:
    post:
      summary: Logout user
      description: Invalidates the current session token
      tags:
        - Authentication
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - token
              properties:
                token:
                  type: string
                  description: JWT token to invalidate
      responses:
        '200':
          description: Logged out successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  message:
                    type: string
                    example: "Logged out successfully"

  /activity/log:
    post:
      summary: Log user activity
      description: Records user activity for analytics and security monitoring
      tags:
        - Activity
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - action
              properties:
                action:
                  type: string
                  example: "encrypt_message"
                  description: Type of action performed
                metadata:
                  type: object
                  additionalProperties: true
                  description: Additional metadata about the action
      responses:
        '200':
          description: Activity logged successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  logged:
                    type: boolean
                    example: true
        '401':
          $ref: '#/components/responses/Unauthorized'

  /admin/stats:
    post:
      summary: Get system statistics
      description: Returns various system statistics (admin only)
      tags:
        - Admin
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - password
              properties:
                password:
                  type: string
                  description: Admin password
      responses:
        '200':
          description: Statistics retrieved successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  stats:
                    type: object
                    properties:
                      totalKeys:
                        type: integer
                        description: Total number of license keys
                      activeKeys:
                        type: integer
                        description: Number of activated keys
                      activeSessions:
                        type: integer
                        description: Current active sessions
                      dailyUsage:
                        type: integer
                        description: Usage count in last 24 hours
        '401':
          $ref: '#/components/responses/Unauthorized'

  /admin/generate-key:
    post:
      summary: Generate new license keys
      description: Generates new license keys (admin only)
      tags:
        - Admin
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - password
              properties:
                password:
                  type: string
                  description: Admin password
                quantity:
                  type: integer
                  minimum: 1
                  maximum: 100
                  default: 1
                  description: Number of keys to generate
                expiresIn:
                  type: integer
                  description: Expiry time in days (optional)
      responses:
        '200':
          description: Keys generated successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  keys:
                    type: array
                    items:
                      type: object
                      properties:
                        id:
                          type: integer
                        key:
                          type: string
                        expires_at:
                          type: string
                          format: date-time
                          nullable: true
                  generated:
                    type: integer
                    description: Number of keys generated

  /admin/keys:
    post:
      summary: List license keys
      description: Returns a paginated list of license keys (admin only)
      tags:
        - Admin
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - password
              properties:
                password:
                  type: string
                  description: Admin password
                page:
                  type: integer
                  minimum: 1
                  default: 1
                limit:
                  type: integer
                  minimum: 1
                  maximum: 100
                  default: 50
      responses:
        '200':
          description: Keys retrieved successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  keys:
                    type: array
                    items:
                      $ref: '#/components/schemas/LicenseKey'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

  /payment/pricing:
    get:
      summary: Get pricing information
      description: Returns current pricing for license keys
      tags:
        - Payment
      security: []
      responses:
        '200':
          description: Pricing information
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  pricing:
                    type: object
                    additionalProperties:
                      $ref: '#/components/schemas/PricingOption'

  /payment/create-payment-intent:
    post:
      summary: Create payment intent
      description: Creates a Stripe payment intent for purchasing license keys
      tags:
        - Payment
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - product_type
                - customer_email
              properties:
                product_type:
                  type: string
                  enum: [single_key, bundle_5, bundle_10]
                  description: Type of product to purchase
                quantity:
                  type: integer
                  minimum: 1
                  default: 1
                  description: Quantity (for single_key only)
                customer_email:
                  type: string
                  format: email
                  description: Customer email address
      responses:
        '200':
          description: Payment intent created
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  client_secret:
                    type: string
                    description: Stripe client secret
                  payment_id:
                    type: string
                    description: Payment intent ID
                  amount:
                    type: integer
                    description: Amount in cents
                  currency:
                    type: string
                    example: "eur"
                  key_count:
                    type: integer
                    description: Number of keys to be generated

  /payment/confirm-payment:
    post:
      summary: Confirm payment and generate keys
      description: Confirms payment and generates license keys
      tags:
        - Payment
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - payment_intent_id
              properties:
                payment_intent_id:
                  type: string
                  description: Stripe payment intent ID
      responses:
        '200':
          description: Payment confirmed and keys generated
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  message:
                    type: string
                  key_count:
                    type: integer
                  keys:
                    type: array
                    items:
                      type: string
                  email_sent:
                    type: boolean

  /payment/status/{payment_id}:
    get:
      summary: Get payment status
      description: Returns the status of a payment
      tags:
        - Payment
      security: []
      parameters:
        - name: payment_id
          in: path
          required: true
          schema:
            type: string
          description: Payment intent ID
      responses:
        '200':
          description: Payment status
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: true
                  payment_id:
                    type: string
                  status:
                    type: string
                  amount:
                    type: integer
                  currency:
                    type: string
                  created:
                    type: string
                    format: date-time
                  completed:
                    type: string
                    format: date-time
                    nullable: true

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    Error:
      type: object
      required:
        - error
      properties:
        error:
          type: string
          description: Error message
        code:
          type: string
          description: Error code
        details:
          type: object
          description: Additional error details

    LicenseKey:
      type: object
      properties:
        id:
          type: integer
          description: Internal key ID
        key_code:
          type: string
          description: License key code
        created_at:
          type: string
          format: date-time
        activated_at:
          type: string
          format: date-time
          nullable: true
        activated_ip:
          type: string
          nullable: true
        is_active:
          type: boolean
        usage_count:
          type: integer
        expires_at:
          type: string
          format: date-time
          nullable: true

    PricingOption:
      type: object
      properties:
        price:
          type: integer
          description: Price in cents
        currency:
          type: string
          example: "eur"
        name:
          type: string
          description: Product name
        description:
          type: string
          description: Product description
        price_formatted:
          type: string
          example: "â‚¬9.99"

    Pagination:
      type: object
      properties:
        page:
          type: integer
          description: Current page number
        limit:
          type: integer
          description: Items per page
        total:
          type: integer
          description: Total number of items
        pages:
          type: integer
          description: Total number of pages

  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          example:
            error: "Invalid request parameters"

    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          example:
            error: "Authentication required"

    Forbidden:
      description: Forbidden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          example:
            error: "Access denied"

    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          example:
            error: "Resource not found"

    RateLimited:
      description: Rate limit exceeded
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          example:
            error: "Rate limit exceeded"

tags:
  - name: System
    description: System health and status endpoints
  - name: Authentication
    description: License key authentication and session management
  - name: Activity
    description: User activity logging and analytics
  - name: Admin
    description: Administrative functions (requires admin access)
  - name: Payment
    description: Payment processing and license key purchasing

---
# performance/optimization.js - Performance Optimization Module
const cluster = require('cluster');
const os = require('os');
const compression = require('compression');
const helmet = require('helmet');
const { createProxyMiddleware } = require('http-proxy-middleware');

class PerformanceOptimizer {
    constructor(app) {
        this.app = app;
        this.setupCluster();
        this.setupCompression();
        this.setupCaching();
        this.setupConnectionPooling();
        this.setupRequestOptimization();
    }
    
    setupCluster() {
        if (cluster.isMaster && process.env.NODE_ENV === 'production') {
            const numCPUs = os.cpus().length;
            console.log(`ðŸš€ Master process starting ${numCPUs} workers`);
            
            // Fork workers
            for (let i = 0; i < numCPUs; i++) {
                cluster.fork();
            }
            
            cluster.on('exit', (worker, code, signal) => {
                console.log(`ðŸ”„ Worker ${worker.process.pid} died. Restarting...`);
                cluster.fork();
            });
            
            // Graceful shutdown
            process.on('SIGTERM', () => {
                console.log('ðŸ›‘ Master received SIGTERM, shutting down gracefully');
                for (const id in cluster.workers) {
                    cluster.workers[id].kill();
                }
            });
        }
    }
    
    setupCompression() {
        // Compression middleware
        this.app.use(compression({
            level: 6,
            threshold: 1024,
            filter: (req, res) => {
                if (req.headers['x-no-compression']) {
                    return false;
                }
                return compression.filter(req, res);
            }
        }));
    }
    
    setupCaching() {
        const NodeCache = require('node-cache');
        
        // In-memory cache for frequently accessed data
        this.cache = new NodeCache({
            stdTTL: 600, // 10 minutes default TTL
            checkperiod: 120, // Check for expired keys every 2 minutes
            useClones: false
        });
        
        // Cache middleware
        this.cacheMiddleware = (duration = 300) => {
            return (req, res, next) => {
                if (req.method !== 'GET') {
                    return next();
                }
                
                const key = req.originalUrl;
                const cached = this.cache.get(key);
                
                if (cached) {
                    res.set('X-Cache', 'HIT');
                    return res.json(cached);
                }
                
                res.sendResponse = res.json;
                res.json = (body) => {
                    this.cache.set(key, body, duration);
                    res.set('X-Cache', 'MISS');
                    res.sendResponse(body);
                };
                
                next();
            };
        };
        
        // Apply caching to specific routes
        this.app.get('/api/payment/pricing', this.cacheMiddleware(3600)); // 1 hour
        this.app.get('/api/health', this.cacheMiddleware(60)); // 1 minute
    }
    
    setupConnectionPooling() {
        // Database connection pooling
        const { Pool } = require('pg');
        
        this.dbPool = new Pool({
            connectionString: process.env.DATABASE_URL,
            max: 20, // Maximum number of connections
            min: 5,  // Minimum number of connections
            idle: 10000, // Close connections after 10 seconds of inactivity
            acquire: 60000, // Maximum time to get connection
            evict: 1000, // Check for idle connections every second
            handleDisconnects: true
        });
        
        // Redis connection pooling
        const Redis = require('ioredis');
        
        this.redisCluster = new Redis.Cluster([
            {
                host: process.env.REDIS_HOST || 'redis',
                port: process.env.REDIS_PORT || 6379,
                password: process.env.REDIS_PASSWORD
            }
        ], {
            redisOptions: {
                password: process.env.REDIS_PASSWORD
            },
            enableOfflineQueue: false,
            maxRetriesPerRequest: 3,
            retryDelayOnFailover: 100,
            lazyConnect: true
        });
    }
    
    setupRequestOptimization() {
        // Request parsing optimization
        this.app.use(express.json({
            limit: '10mb',
            type: 'application/json'
        }));
        
        this.app.use(express.urlencoded({
            extended: true,
            limit: '10mb'
        }));
        
        // Security headers optimization
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    scriptSrc: ["'self'", "'unsafe-inline'"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
                    imgSrc: ["'self'", "data:", "https:"]
                }
            },
            hsts: {
                maxAge: 31536000,
                includeSubDomains: true,
                preload: true
            }
        }));
        
        // Request timeout
        this.app.use((req, res, next) => {
            req.setTimeout(30000, () => {
                res.status(408).json({ error: 'Request timeout' });
            });
            next();
        });
    }
    
    // Database query optimization
    async executeQuery(query, params = []) {
        const client = await this.dbPool.connect();
        try {
            const start = Date.now();
            const result = await client.query(query, params);
            const duration = Date.now() - start;
            
            // Log slow queries
            if (duration > 1000) {
                console.warn(`ðŸŒ Slow query (${duration}ms):`, query);
            }
            
            return result;
        } finally {
            client.release();
        }
    }
    
    // Redis operations with retry logic
    async redisOperation(operation, ...args) {
        let retries = 3;
        while (retries > 0) {
            try {
                return await this.redisCluster[operation](...args);
            } catch (error) {
                retries--;
                if (retries === 0) {
                    console.error(`Redis operation failed: ${operation}`, error);
                    throw error;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
    
    // Metrics collection
    setupMetrics() {
        const prometheus = require('prom-client');
        
        // Create metrics
        this.httpRequestDuration = new prometheus.Histogram({
            name: 'http_request_duration_seconds',
            help: 'Duration of HTTP requests in seconds',
            labelNames: ['method', 'route', 'status_code'],
            buckets: [0.1, 0.5, 1, 2, 5]
        });
        
        this.httpRequestsTotal = new prometheus.Counter({
            name: 'http_requests_total',
            help: 'Total number of HTTP requests',
            labelNames: ['method', 'route', 'status_code']
        });
        
        this.activeConnections = new prometheus.Gauge({
            name: 'active_connections',
            help: 'Number of active connections'
        });
        
        this.databaseConnections = new prometheus.Gauge({
            name: 'database_connections_active',
            help: 'Number of active database connections'
        });
        
        // Middleware to collect metrics
        this.app.use((req, res, next) => {
            const start = Date.now();
            
            res.on('finish', () => {
                const duration = (Date.now() - start) / 1000;
                const route = req.route ? req.route.path : req.path;
                
                this.httpRequestDuration
                    .labels(req.method, route, res.statusCode)
                    .observe(duration);
                    
                this.httpRequestsTotal
                    .labels(req.method, route, res.statusCode)
                    .inc();
            });
            
            next();
        });
        
        // Metrics endpoint
        this.app.get('/metrics', async (req, res) => {
            res.set('Content-Type', prometheus.register.contentType);
            res.end(await prometheus.register.metrics());
        });
        
        // Update database connection metrics
        setInterval(() => {
            this.databaseConnections.set(this.dbPool.totalCount);
        }, 5000);
    }
    
    // Memory optimization
    setupMemoryOptimization() {
        // Monitor memory usage
        setInterval(() => {
            const usage = process.memoryUsage();
            const memoryUsage = {
                rss: Math.round(usage.rss / 1024 / 1024),
                heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
                heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
                external: Math.round(usage.external / 1024 / 1024)
            };
            
            // Log if memory usage is high
            if (memoryUsage.heapUsed > 500) {
                console.warn('ðŸ§  High memory usage:', memoryUsage);
            }
            
            // Force garbage collection if available
            if (global.gc && memoryUsage.heapUsed > 800) {
                global.gc();
            }
        }, 30000);
        
        // Handle memory pressure
        process.on('warning', (warning) => {
            if (warning.name === 'MaxListenersExceededWarning') {
                console.warn('âš ï¸ Memory warning:', warning);
            }
        });
    }
    
    // Load balancing for multiple instances
    setupLoadBalancer() {
        if (process.env.NODE_ENV === 'production') {
            const proxy = createProxyMiddleware({
                target: 'http://localhost:3000',
                changeOrigin: true,
                ws: true,
                router: (req) => {
                    // Simple round-robin load balancing
                    const instances = [
                        'http://localhost:3001',
                        'http://localhost:3002',
                        'http://localhost:3003'
                    ];
                    const index = Math.floor(Math.random() * instances.length);
                    return instances[index];
                }
            });
            
            this.app.use('/api', proxy);
        }
    }
}

module.exports = PerformanceOptimizer;

---
# performance/load-testing.js - Load Testing Configuration
const autocannon = require('autocannon');
const { performance } = require('perf_hooks');

class LoadTester {
    constructor(baseUrl = 'http://localhost:3000') {
        this.baseUrl = baseUrl;
        this.results = [];
    }
    
    async runHealthCheckTest() {
        console.log('ðŸƒâ€â™‚ï¸ Running health check load test...');
        
        const result = await autocannon({
            url: `${this.baseUrl}/api/health`,
            connections: 50,
            pipelining: 1,
            duration: 30,
            title: 'Health Check Load Test'
        });
        
        this.results.push({
            test: 'health_check',
            ...result
        });
        
        return result;
    }
    
    async runAuthenticationTest() {
        console.log('ðŸ” Running authentication load test...');
        
        const result = await autocannon({
            url: `${this.baseUrl}/api/auth/validate`,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                token: 'invalid-token-for-testing'
            }),
            connections: 20,
            pipelining: 1,
            duration: 30,
            title: 'Authentication Load Test'
        });
        
        this.results.push({
            test: 'authentication',
            ...result
        });
        
        return result;
    }
    
    async runPaymentTest() {
        console.log('ðŸ’³ Running payment endpoint load test...');
        
        const result = await autocannon({
            url: `${this.baseUrl}/api/payment/pricing`,
            connections: 30,
            pipelining: 1,
            duration: 30,
            title: 'Payment Pricing Load Test'
        });
        
        this.results.push({
            test: 'payment_pricing',
            ...result
        });
        
        return result;
    }
    
    async runStressTest() {
        console.log('ðŸ˜° Running stress test...');
        
        const result = await autocannon({
            url: `${this.baseUrl}/api/health`,
            connections: 100,
            pipelining: 10,
            duration: 60,
            title: 'Stress Test'
        });
        
        this.results.push({
            test: 'stress_test',
            ...result
        });
        
        return result;
    }
    
    async runFullTestSuite() {
        console.log('ðŸš€ Starting full load test suite...');
        
        const tests = [
            this.runHealthCheckTest(),
            this.runAuthenticationTest(),
            this.runPaymentTest(),
            this.runStressTest()
        ];
        
        const results = await Promise.all(tests);
        
        this.generateReport();
        return results;
    }
    
    generateReport() {
        console.log('\nðŸ“Š Load Test Report');
        console.log('===================');
        
        this.results.forEach(result => {
            console.log(`\n${result.test.toUpperCase()}:`);
            console.log(`  Requests/sec: ${result.requests.average}`);
            console.log(`  Latency (avg): ${result.latency.average}ms`);
            console.log(`  Latency (p99): ${result.latency.p99}ms`);
            console.log(`  Throughput: ${result.throughput.average} bytes/sec`);
            console.log(`  Errors: ${result.errors}`);
            console.log(`  Timeouts: ${result.timeouts}`);
            
            // Performance thresholds
            if (result.requests.average < 100) {
                console.log('  âš ï¸ WARNING: Low throughput');
            }
            if (result.latency.p99 > 1000) {
                console.log('  âš ï¸ WARNING: High latency');
            }
            if (result.errors > 0) {
                console.log('  âŒ ERROR: Requests failed');
            }
            if (result.requests.average > 500 && result.latency.average < 100) {
                console.log('  âœ… EXCELLENT: High performance');
            }
        });
        
        // Overall assessment
        const avgThroughput = this.results.reduce((sum, r) => sum + r.requests.average, 0) / this.results.length;
        const avgLatency = this.results.reduce((sum, r) => sum + r.latency.average, 0) / this.results.length;
        const totalErrors = this.results.reduce((sum, r) => sum + r.errors, 0);
        
        console.log('\nðŸŽ¯ OVERALL PERFORMANCE:');
        console.log(`  Average Throughput: ${avgThroughput.toFixed(2)} req/sec`);
        console.log(`  Average Latency: ${avgLatency.toFixed(2)}ms`);
        console.log(`  Total Errors: ${totalErrors}`);
        
        if (avgThroughput > 300 && avgLatency < 200 && totalErrors === 0) {
            console.log('  ðŸ† PERFORMANCE: EXCELLENT');
        } else if (avgThroughput > 150 && avgLatency < 500 && totalErrors < 10) {
            console.log('  âœ… PERFORMANCE: GOOD');
        } else {
            console.log('  âš ï¸ PERFORMANCE: NEEDS IMPROVEMENT');
        }
    }
}

// CLI interface
if (require.main === module) {
    const baseUrl = process.argv[2] || 'http://localhost:3000';
    const tester = new LoadTester(baseUrl);
    
    tester.runFullTestSuite()
        .then(() => {
            console.log('\nâœ… Load testing completed');
            process.exit(0);
        })
        .catch(error => {
            console.error('âŒ Load testing failed:', error);
            process.exit(1);
        });
}

module.exports = LoadTester;

---
# scripts/performance-monitor.js - Real-time Performance Monitoring
const os = require('os');
const v8 = require('v8');
const EventEmitter = require('events');

class PerformanceMonitor extends EventEmitter {
    constructor() {
        super();
        this.metrics = {
            cpu: 0,
            memory: {},
            gc: {},
            eventLoop: 0,
            requests: {
                total: 0,
                errors: 0,
                avgResponseTime: 0
            }
        };
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        // Monitor CPU usage
        setInterval(() => {
            this.updateCPUUsage();
        }, 5000);
        
        // Monitor memory usage
        setInterval(() => {
            this.updateMemoryUsage();
        }, 1000);
        
        // Monitor garbage collection
        this.monitorGarbageCollection();
        
        // Monitor event loop lag
        setInterval(() => {
            this.measureEventLoopLag();
        }, 1000);
        
        // Set up alerts
        this.setupAlerts();
    }
    
    updateCPUUsage() {
        const cpus = os.cpus();
        let totalIdle = 0;
        let totalTick = 0;
        
        cpus.forEach(cpu => {
            for (const type in cpu.times) {
                totalTick += cpu.times[type];
            }
            totalIdle += cpu.times.idle;
        });
        
        const idle = totalIdle / cpus.length;
        const total = totalTick / cpus.length;
        const usage = 100 - Math.floor(100 * idle / total);
        
        this.metrics.cpu = usage;
        
        if (usage > 80) {
            this.emit('alert', {
                type: 'cpu',
                level: 'warning',
                message: `High CPU usage: ${usage}%`
            });
        }
    }
    
    updateMemoryUsage() {
        const usage = process.memoryUsage();
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        
        this.metrics.memory = {
            rss: usage.rss,
            heapTotal: usage.heapTotal,
            heapUsed: usage.heapUsed,
            external: usage.external,
            systemTotal: totalMem,
            systemFree: freeMem,
            systemUsed: totalMem - freeMem,
            heapUsedPercent: (usage.heapUsed / usage.heapTotal) * 100,
            systemUsedPercent: ((totalMem - freeMem) / totalMem) * 100
        };
        
        if (this.metrics.memory.heapUsedPercent > 85) {
            this.emit('alert', {
                type: 'memory',
                level: 'warning',
                message: `High heap usage: ${this.metrics.memory.heapUsedPercent.toFixed(2)}%`
            });
        }
    }
    
    monitorGarbageCollection() {
        // V8 GC monitoring
        const gcStats = v8.getHeapStatistics();
        
        this.metrics.gc = {
            heapSize: gcStats.total_heap_size,
            heapSizeExecutable: gcStats.total_heap_size_executable,
            heapPhysicalSize: gcStats.total_physical_size,
            heapAvailableSize: gcStats.total_available_size,
            usedHeapSize: gcStats.used_heap_size,
            mallocedMemory: gcStats.malloced_memory,
            peakMallocedMemory: gcStats.peak_malloced_memory
        };
        
        // Track GC events
        if (global.gc) {
            const originalGC = global.gc;
            global.gc = () => {
                const start = Date.now();
                originalGC();
                const duration = Date.now() - start;
                
                this.emit('gc', {
                    duration,
                    timestamp: start
                });
                
                if (duration > 100) {
                    this.emit('alert', {
                        type: 'gc',
                        level: 'warning',
                        message: `Long GC pause: ${duration}ms`
                    });
                }
            };
        }
    }
    
    measureEventLoopLag() {
        const start = process.hrtime.bigint();
        
        setImmediate(() => {
            const end = process.hrtime.bigint();
            const lag = Number(end - start) / 1000000; // Convert to milliseconds
            
            this.metrics.eventLoop = lag;
            
            if (lag > 100) {
                this.emit('alert', {
                    type: 'eventloop',
                    level: 'warning',
                    message: `High event loop lag: ${lag.toFixed(2)}ms`
                });
            }
        });
    }
    
    setupAlerts() {
        this.on('alert', (alert) => {
            console.warn(`âš ï¸ PERFORMANCE ALERT [${alert.type}]: ${alert.message}`);
            
            // Send to monitoring service
            this.sendToMonitoring(alert);
        });
        
        this.on('gc', (gcEvent) => {
            console.log(`ðŸ—‘ï¸ GC Event: ${gcEvent.duration}ms`);
        });
    }
    
    sendToMonitoring(alert) {
        // Integration with external monitoring services
        // Prometheus, DataDog, New Relic, etc.
        
        if (process.env.PROMETHEUS_GATEWAY) {
            // Send to Prometheus Push Gateway
            this.sendToPrometheus(alert);
        }
        
        if (process.env.SLACK_WEBHOOK_URL) {
            // Send to Slack
            this.sendToSlack(alert);
        }
    }
    
    getMetrics() {
        return {
            ...this.metrics,
            timestamp: Date.now(),
            uptime: process.uptime(),
            version: process.version,
            platform: process.platform,
            arch: process.arch
        };
    }
    
    getHealthScore() {
        let score = 100;
        
        // CPU penalty
        if (this.metrics.cpu > 80) score -= 20;
        else if (this.metrics.cpu > 60) score -= 10;
        
        // Memory penalty
        if (this.metrics.memory.heapUsedPercent > 85) score -= 20;
        else if (this.metrics.memory.heapUsedPercent > 70) score -= 10;
        
        // Event loop penalty
        if (this.metrics.eventLoop > 100) score -= 15;
        else if (this.metrics.eventLoop > 50) score -= 5;
        
        // Request error penalty
        const errorRate = this.metrics.requests.errors / this.metrics.requests.total;
        if (errorRate > 0.05) score -= 25;
        else if (errorRate > 0.01) score -= 10;
        
        return Math.max(0, score);
    }
    
    generateReport() {
        const metrics = this.getMetrics();
        const healthScore = this.getHealthScore();
        
        console.log('\nðŸ“Š PERFORMANCE REPORT');
        console.log('====================');
        console.log(`Health Score: ${healthScore}/100`);
        console.log(`CPU Usage: ${metrics.cpu}%`);
        console.log(`Memory Usage: ${metrics.memory.heapUsedPercent.toFixed(2)}%`);
        console.log(`Event Loop Lag: ${metrics.eventLoop.toFixed(2)}ms`);
        console.log(`Uptime: ${(metrics.uptime / 3600).toFixed(2)} hours`);
        
        return {
            healthScore,
            metrics,
            timestamp: Date.now()
        };
    }
}

module.exports = PerformanceMonitor;
